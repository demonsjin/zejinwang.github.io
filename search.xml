<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ubuntu Server 18.04 部署]]></title>
    <url>%2F2019%2F09%2F12%2FUbuntu-Server-Deploy%2F</url>
    <content type="text"><![CDATA[本文总结了在配置实验室新入的基于Ubuntu Server 18.04操作系统工作站过程中遇到相应问题时的解决方法，旨在为后续配置基于ubuntu 操作系统的服务器平台提供参考。1. Ubuntu Server 18.04安装一、下载Ubuntu Server 18.04的ios镜像文件下载链接：https://ubuntu.com/download/server/thank-you?version=18.04.3&amp;architecture=amd64二、 下载ultraiso下载链接：http://cn.ultraiso.net/xiazai.html三、通过ultraiso将iso镜像文件 写入U盘详细步骤参见：ultraiso刻录U盘启动盘下载安装Ubuntu18.04系统2. 内外网卡配置Ubuntu Server18.4的网关配置不同于以往版本，18.04的网卡配置在/etc/netplan/50-cloud-ini.yaml中进行，配置过程如下：12#打开netpaln配置文件$ sudo vim /etc/netplan/50-cloud-ini.yaml文件内容修改为：1234567891011network: Version: 2 ethernets: enp0s31f6: dhcp4: true enp4s0: Addresses: [192.168.3.233/24] dhcp4: no optional: true Nameservers: Addresses: [8.8.8.8,8.8.4.4]配置参数解释：enp0s31f6 和 enp4s0 为需要配置网卡的实际名称，本例中 enp0s31f6 是外网网卡名称， enp4s0 是内网网卡名称。dhcp4 : true/no 代表IPv4是否启用。dhcp6 : true/no 代表IPv6是否启用。Addresses : 设备的IP地址和IP地址对应的子网掩码，[192.168.3.233/24]表示IP地址为192.168.3.233，24表示子网掩码为255.255.255.0。Nameservers : 表示由逗号隔开的DNS服务器列表。外网网卡设置动态IP，只需要配置dhcp4为 true；内网网卡设置固定静态IP，需将IP固定为分配的内网IP，同时配置dhcp为 no，并配置对应的Nameservers的DNS服务器列表。配置完成后，使用测试命令查看是否配置成功：1$ sudo netplan try配置准确无误后，应用新的配置：1$ sudo netpaln apply12# 查看更新后的网络信息$ ifconfig3. 远程连接在ubuntu操作系统上进行远程连接主要通过 SSH 执行，SSH 是一个远程访问和数据传输的安全协议，能够加密用户密码和数据，保证安全传输。OpenSSH 是基于 SSH 协议实现的开源软件，包括了ssh (远程连接)、scp (远程传输)等工具。安装查看当前是否已安装ssh1$ ps -aux | grep ssh本地安装客 client 端1$ sudo apt-get install openssh-client服务器安装 server 端1$ sudo apt-get install openssh-server配置文件SSH配置文件在/etc/ssh文件夹下，客户端配置文件为ssh_config，服务器端配置文件为sshd_config 。按需求对上述文件进行相应修改，比如端口号为 22修改完成后，重启 SSH服务：123$ sudo service ssh restart# 或者$ sudo systemctl restart ssh修改SSH登录密码登录ssh后，通过passwd命令，两次输入新密码。服务器公钥查看和删除known_hosts存放在~/.ssh文件夹内，用于保存已连接过的服务器公钥，其目的是确保服务器连接的安全性，第一次连接时需要会询问你是否添加。搜索已连接过服务器的公钥：1234# 命令形如$ ssh-keygen -F hostname [-f known_hosts_file] [-l]# 比如寻找 IP为192.168.3.233的服务器的公钥$ ssh-keygen -F 192.168.3.233当服务器重装后，会生成新的服务器公钥，需要删除客户端当前公钥，然后重新设置。删除特定服务器(IP为192.168.3.233)的本地存储公钥1234$ ssh-keygen -f "/home/wzj/.ssh/known_hosts" -R 192.168.3.233# Host 132.232.142.219 found: line 10/home/wzj/.ssh/known_hosts updated.Original contents retained as /home/wzj/.ssh/known_hosts.old4. 用户添加与权限设置一、LINUX(UBUNTU/CENTOS)用户添加删除修改1、创建用户：123adduser web #新建web用户useradd web #添加web 用户passwd web #给web用户设置密码12345678#新建web用户并指定用户组为 admin用户组,并自动建立登录目录useradd web -g admin -n -m #给web 用户设置密码passwd web #创建admin用户，并指定属组为admin 用户id为10000useradd -r -m -s /bin/bash -g admin -u 10000 admin1234567891011121314useradd(选项)(参数)-c&lt;备注&gt;：加上备注文字。备注文字会保存在passwd的备注栏位中； -d&lt;登入目录&gt;：指定用户登入时的启始目录； -D：变更预设值； -e&lt;有效期限&gt;：指定帐号的有效期限； -f&lt;缓冲天数&gt;：指定在密码过期后多少天即关闭该帐号； -g&lt;群组&gt;：指定用户所属的群组； -G&lt;群组&gt;：指定用户所属的附加群组； -m：自动建立用户的登入目录； -M：不要自动建立用户的登入目录； -n：取消建立以用户名称为名的群组； -r：建立系统帐号； -s：指定用户登入后所使用的shell； -u：指定用户id。2、给已有的用户增加工作组12345678#给web用户设置admin附属用户组usermod -G admin web #给用户设置添加多个用户组usermod -g web -G admin,www web #给web用户设置主用户组web组，admin,www附属用户组#给web用户设置admin用户组gpasswd -a web admin3、新建用户同时增加工作组1useradd -g admin web #新建web用户并增加到admin工作组注：-g 所属组-d 家目录-s 所用的SHELL4、临时关闭方法一 /etc/shadow文件中属于该用户的行的第二个字段（密码）前面加上 就可以了。想恢复该用户，去掉即可。 方法二 使用命令关闭用户账号：1passwd web –l重新释放：1passwd web –u5、永久性删除用户账号123userdel webgroupdel webusermod –G web web #（强制删除该用户的主目录和主目录下的所有文件和子目录）6、从组中删除用户编辑/etc/group 找到用户组admin那一行，删除用户名web 或者用命令1gpasswd -d web A7、显示用户信息12id usercat /etc/passwd二、用户组 LINUX(UBUNTU/CENTOS) 添加删除修改1、建工作组1groupadd admin #新建admin工作组2、修改用户组1groupmod -n newadmin admin #修改admin用户组名称改为newadmin3、删除用户组1groupdel admin #删除admin用户组4.查看用户的用户组信息1groups web #==查看web所有用户组==5. 挂载硬盘或磁盘因fdisk分区最大只能2T,当硬盘容量大于2T时，就需要使用parted来分区。5.1 挂载小于2T硬盘或磁盘参考博客：ubuntu下添加硬盘，分区以及自动挂载5.2 挂载大于2T硬盘或磁盘参考博客：Ubuntu挂载3T硬盘或大于2T磁盘6. 更改apt源进行备份编辑文件前先备份12# 备份$ cp /etc/apt/sources.list /etc/apt/sources.list.bak添加阿里源在/etc/apt/sources.list文件中清空原有信息，并添加以下条目1234567891011#添加阿里源deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse更新源123# 更新$ sudo apt-get update$ sudo apt-get upgrade诸如163源、清华源、中科大源等参见参考链接。参考链接国内使用Ubuntu 18.04更新缓慢，更换apt源为国内源Ubuntu Server 18.04 更改软件源到国内镜像7. 显卡配置1 安装显卡驱动1.1 禁用 nouveau驱动在/etc/modprobe.d/blacklist.conf 里添加如下内容，12blacklist nouveauoptions nouveau modeset=0并执行 sudo update-initramfs -u 命令,重启 reboot 后用 lsmod | grep nouveau, 如果没有任何输出说明禁用成功。1.2 安装 NVIDIA显卡驱动ubuntu 18.04 直接使用sudo ubuntu-drivers autoinstall安装的是390的驱动，cuda 10 显卡必须是410以上，所以要安装新一点的驱动安装更新版本的驱动可以先添加源：12$ sudo add-apt-repository ppa:graphics-drivers/ppa$ sudo apt update然后执行：1234567891011$ ubuntu-drivers devices==/sys/devices/pci0000:64/0000:64:00.0/0000:65:00.0/0000:66:10.0/0000:67:00.0 ==modalias : pci:v000010DEd00001B00sv000010DEsd0000119Abc03sc00i00vendor : NVIDIA Corporationmodel : GP102 [TITAN X]driver : nvidia-driver-415 - third-party freedriver : nvidia-driver-435 - third-party free recommendeddriver : nvidia-driver-430 - third-party freedriver : nvidia-driver-410 - third-party freedriver : nvidia-driver-390 - third-party freedriver : xserver-xorg-video-nouveau - distro free builtin命令输出driver : nvidia-driver-435 - third-party free recommended推荐安装的驱动nvidia-driver-435 。这里我选择了安装 nvidia-driver-430。安装命令1$ sudo apt install nvidia-driver-4302 安装 CUDA2.1 下载cuda安装包下载地址：https://developer.nvidia.com/cuda-toolkit-archive这里下载：cuda_10.1.243_418.87.00_linux.run下载cuda版本选择平台如下2.2 安装安装命令与上图Base Installer介绍的一致：12$ wget http://developer.download.nvidia.com/compute/cuda/10.1/Prod/local_installers/cuda_10.1.243_418.87.00_linux.run$ sudo sh cuda_10.1.243_418.87.00_linux.run注意:第一项显卡驱动不要装，之前已经安装过驱动 nvidia-driver-430 ，剩下的都安装。2.3 配置环境变量考虑到环境变量要多用户共享，需要将其写入到/etc/profile ，如果环境变量不进行共享，只是本用户可用，则需将其写入到~/.bashrc。输入内容为：12export PATH=/usr/local/cuda-10.1/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-10.1/lib64:$LD_LIBRARY_PATH保存退出，并输入下面命令使环境配置生效：1234# 多用户$ source /etc/profile# 单用户$ source ~/.bashrc2.6 测试 cuda 是否安装成功切换到 CUDA 9.1 Samples 默认安装路径(即在/home/用户/ NVIDIA_CUDA-10.1_Samples 目录下), 终端下输入1234$ cd ~/NVIDIA_CUDA-10.1_Samples$ sudo make all -j8$ cd bin/x86_64/linux/release$ ./deviceQuery如果CUDA安装成功，则显示相关信息 Result=PASS，具体如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445$ ./deviceQuery./deviceQuery Starting... CUDA Device Query (Runtime API) version (CUDART static linking)Detected 1 CUDA Capable device(s)Device 0: "GeForce GTX 1050 Ti" CUDA Driver Version / Runtime Version 10.2 / 10.1 CUDA Capability Major/Minor version number: 6.1 Total amount of global memory: 4039 MBytes (4234936320 bytes) ( 6) Multiprocessors, (128) CUDA Cores/MP: 768 CUDA Cores GPU Max Clock rate: 1392 MHz (1.39 GHz) Memory Clock rate: 3504 Mhz Memory Bus Width: 128-bit L2 Cache Size: 1048576 bytes Maximum Texture Dimension Size (x,y,z) 1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384) Maximum Layered 1D Texture Size, (num) layers 1D=(32768), 2048 layers Maximum Layered 2D Texture Size, (num) layers 2D=(32768, 32768), 2048 layers Total amount of constant memory: 65536 bytes Total amount of shared memory per block: 49152 bytes Total number of registers available per block: 65536 Warp size: 32 Maximum number of threads per multiprocessor: 2048 Maximum number of threads per block: 1024 Max dimension size of a thread block (x,y,z): (1024, 1024, 64) Max dimension size of a grid size (x,y,z): (2147483647, 65535, 65535) Maximum memory pitch: 2147483647 bytes Texture alignment: 512 bytes Concurrent copy and kernel execution: Yes with 2 copy engine(s) Run time limit on kernels: Yes Integrated GPU sharing Host Memory: No Support host page-locked memory mapping: Yes Alignment requirement for Surfaces: Yes Device has ECC support: Disabled Device supports Unified Addressing (UVA): Yes Device supports Compute Preemption: Yes Supports Cooperative Kernel Launch: Yes Supports MultiDevice Co-op Kernel Launch: Yes Device PCI Domain ID / Bus ID / location ID: 0 / 5 / 0 Compute Mode: &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 10.2, CUDA Runtime Version = 10.1, NumDevs = 1Result = PASS2.7 查看 cuda 版本1cat /usr/local/cuda/version.txt3 安装 cudnn3.1 下载cudnn下载地址：https://developer.nvidia.com/rdp/cudnn-archive3.2 安装 cudnn123$ sudo dpkg -i libcudnn7_7.6.1.34-1+cuda10.1_amd64.deb$ sudo dpkg -i libcudnn7-dev_7.6.1.34-1+cuda10.1_amd64.deb$ sudo dpkg -i libcudnn7-doc_7.6.1.34-1+cuda10.1_amd64.deb3.3 测试 cudnn参考博客：https://blog.csdn.net/u014754541/article/details/971082823.4 查看 cudnn 版本1$ cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 28. 局域网下网络磁盘共享8.1 设置 Windows共享文件夹 供 Ubuntu 访问ubuntu 安装 cifs-utils1$ sudo apt-get install cifs-utils创建 Windows 共享文件夹参考 ubuntu-server 与 windows 共享文件夹查看 Windows 局域网 ip1$ ipconfigubuntu 挂载 Windows 共享文件夹创建一个文件夹来挂载共享文件夹1$ sudo mkdir share_wzj挂载1$ sudo mount -t cifs //192.168.3.233/data -o username=wangzj,password=1234568.2 设置 Ubuntu共享文件夹 供 Windows 访问参考 ubuntu-server 与 windows 共享文件夹 设置 ubuntu 共享文件夹供 windows 访问 部分。9. anaconda 多用户共享安装多用户共享安装主要需要将 anaconda安装到/usr/local路径下，并在/etc/profile文件中添加以下语句：1234567891011121314# &gt;&gt;&gt; conda initialize &gt;&gt;&gt;# !! Contents within this block are managed by &apos;conda init&apos; !!__conda_setup=&quot;$(&apos;/usr/local/anaconda3/bin/conda&apos; &apos;shell.bash&apos; &apos;hook&apos; 2&gt; /dev/null)&quot;if [ $? -eq 0 ]; then eval &quot;$__conda_setup&quot;else if [ -f &quot;/usr/local/anaconda3/etc/profile.d/conda.sh&quot; ]; then . &quot;/usr/local/anaconda3/etc/profile.d/conda.sh&quot; else export PATH=&quot;/usr/local/anaconda3/bin:$PATH&quot; fifiunset __conda_setup# &lt;&lt;&lt; conda initialize &lt;&lt;&lt;最后，在终端输入：1$ source /etc/profile10. 修改conda源为清华源清华大学开源软件镜像站：https://mirror.tuna.tsinghua.edu.cn/修改conda源为清华源通过修改用户目录下的.condarc文件执行，每个用户都需要自行修改：123456789101112channels: - defaultsshow_channel_urls: truedefault_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/rcustom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud11. vim相关配置打开用户目录下的.vimrc文件，按需求进行简单配置1$ sudo vim ~/.vimrc打开文件后，输入123456set nu "显示行号:set tabstop=4 "tab 空格数设为4set laststatus=2 "底部显示打开文件名syntax on "自动语法高亮set cursorline "突出显示当前行set hlsearch "搜索时高亮显示被找到文本12. 修改时区和时间查看当前系统时间12$ date -RWed, 11 Sep 2019 15:51:52 +0800北京地处东八区，如果显示的不是 0800，则需要对时区进行修改1.运行 tzselect12#这里选择Asia，确认之后选择China，最后选择Beijing$ tezselect2.复制到 \etc 目录下1$ cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime3.再次查看时间，已修改为北京时间1$ date -RSome say the world will end in fire,Some say in ice.From what I’ve tasted of desireI hold with those who favor fire.But if it had to perish twice,I think I know enough of hateTo say that for destruction iceIs also greatAnd would suffice.]]></content>
      <tags>
        <tag>Ubuntu</tag>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTex常用命令]]></title>
    <url>%2F2019%2F07%2F08%2FLaTex%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[文章排版常用数学符号本部分整理LaTex常用数学符号及数学关系表达的命令。数学符号希腊字母表小写字母希腊字母符号表示希腊字母符号表示希腊字母符号表示$\alpha$\alpha$\iota$\iota$\varrho$\varrho$\beta$\beta$\kappa$\kappa$\sigma$\sigma$\gamma$\gamma$\lambda$\lambda$\varsigma$\varsigma$\delta$\delta$\mu$\mu$\tau$\tau$\epsilon$\epsilon$\nu$\nu$\upsilon$\upsilon$\varepsilon$\varepsilon$\xi$\xi$\phi$\phi$\zeta$\zeta$o$o$\varphi$\varphi$\eta$\eta$\pi$\pi$\chi$\chi$\theta$\theta$\varpi$\varpi$\psi$\psi$\vartheta$\vartheta$\rho$\rho$\omega$\omega大写字母大写字母表示符号的第一个字母需大写。希腊字母符号表示希腊字母符号表示希腊字母符号表示$\Gamma$\Gamma$\Xi$\Xi$\Phi$\Phi$\Delta$\Delta$\Pi$\Pi$Psi$\Psi$\Theta$\Theta$\Sigma$\Sigma$\Omega$\Omega$\Lambda$\Lambda$\Upsilon$\Upsilon运算符号二元关系符下面命令前加上\not命令，可得到否定形式。符号命令符号命令符号命令$&lt;$&lt;$&gt;$&gt;$=$=$\leq$\leq or \le$\geq$\geq or \ge$\equiv$\equiv$\subset$\subset$\supset$\supset$\approx$\approx$\subseteq$\subseteq$\subseteq$\supseteq$\sim$\sim$\in$\in$\cong$\cong$\approx$\approx$\propto$\propto$\parallel$\parallel$\perp$\perp$\ll$\ll$\gg$\gg$\simeq$\simeq二元运算符符号命令符号命令符号命令$\pm$\pm$\mp$\mp$\cdot$\cdot$\times$\times$\div$\div$\odot$\odot$\cup$\cup$\cap$\cap$\oplus$\oplus$\vee$\vee or \lor$\land$\wedge or \land$\circ$\circ积分符号命令符号命令符号命令$\int$\int$\iint$\iint$\iiint$\iiint根号符号命令$\sqrt[a]{x}$\sqrt[a]{x}上下标符号命令符号命令$x^a$x^a$x_a$x_a分数符号命令$\frac{a}{b}$\frac{a}{b}求和|积符号命令符号命令$\sum$\sum$\sum_{i=1}^{n}$\sum_{i=1}^{n}$\sum\limits_{i=1}^{n}$\sum\limits_{i=1}^{n}$\prod$\prod偏导符号命令$\partial$\partial其他符号箭头符号命令符号命令符号命令$\leftarrow$\leftarrow$\rightarrow$\rightarrow$\leftrightarrow$\leftrightarrow$\Leftarrow$\Leftarrow$\Rightarrow$\Rightarrow$\Leftrightarrow$\Leftrightarrow注音符号命令符号命令符号命令$\bar{x}$\bar{x}$\vec{x}$\vec{x}$\hat{x}$\hat{x}$\dot{x}$\dot{x}$\mathring{x}$\mathring{x}$\tilde{x}$\tilde{x}省略号符号命令符号命令$x_1,\dots,x_2$\dots$x_1,\cdots,x_2$\cdots$x_1,\vdots,x_2$\vdots$x_1,\ddots ,x_2$\ddots数字粗体|空白表示符号命令符号命令$\mathbf{R}$\mathbf{R}$\mathbb{R}$\mathbb{R}其他符号命令符号命令符号命令$\lfloor$\lfloor$\rfloor$\rfloor$\exists$\exists$\lceil$\lceil$\rceil$\rceil$\infty$\infty$\hbar$\hbar$\angle$\angle$\forall$\forall$\because$\because$\therefore$\therefore$\neg$\neg or \lnot矩阵使用\array环境生成矩阵123\begin&#123;array&#125;[外部对齐]&#123;列对齐&#125;true行列内容\end&#123;array外部对齐参数：整个矩阵和周围对象的纵向关系：居顶：t居中（缺省）：c居底：b列对齐参数居左：l居中：c居右：r换行：\\列分隔：&amp;eg：\begin{array}{ccc} x_1 & x_2 & \cdots \\ x_3 & x_4 & \cdots \\ \vdots & \vdots & \ddots \\ \end{array}12345\begin&#123;array&#125;&#123;ccc&#125; truex_1 &amp; x_2 &amp; \cdots \\ truex_3 &amp; x_4 &amp; \cdots \\ true\vdots &amp; \vdots &amp; \ddots \\\end&#123;array&#125;（分隔符对齐非必要，仅出于个人习惯）使用array环境产生的矩阵没有旁边的各种分隔符，可以用以下环境替代产生分隔符：\begin{pmatrix} a & b \\ c & d \end{pmatrix}1234\begin&#123;pmatrix&#125; a &amp; b \\ c &amp; d\end&#123;pmatrix&#125;\begin{vmatrix} a & b \\ c & d \end{vmatrix}1234\begin&#123;vmatrix&#125; a &amp; b \\ c &amp; d\end&#123;vmatrix&#125;分段函数使用\cases环境可以生成分段函数，同样可以用于生成方程组。eg：y= % 换行是非必要的 \begin{cases} -x, \quad x\leq 0 \\ x, \quad x > 0 \end{cases}12345y= % 换行是非必要的\begin&#123;cases&#125;true-x, \quad x\leq 0 \\truex, \quad x &gt; 0\end&#123;cases&#125;ReferenceLaTeX-常用数学符号一份不太简短的LATEX2ε介绍(PDF)LATEX Notes雷太赫排版系统简介第二版v2.03 (PDF)The Comprehensive LATEX Symbol List (PDF)Some say the world will end in fire,Some say in ice.From what I’ve tasted of desireI hold with those who favor fire.But if it had to perish twice,I think I know enough of hateTo say that for destruction iceIs also greatAnd would suffice.]]></content>
      <categories>
        <category>LaTex</category>
      </categories>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解KL散度(相对熵)]]></title>
    <url>%2F2019%2F07%2F07%2F%E7%90%86%E8%A7%A3KL%E6%95%A3%E5%BA%A6-%E7%9B%B8%E5%AF%B9%E7%86%B5%2F</url>
    <content type="text"><![CDATA[信息熵信息熵：描述随机变量不确定性程度的量，对于连续型随机变量称为微分熵。信息熵的表达式H(x)=-\int p(x)ln^{p(x)}dx信息熵可认为是表征编码分布 $p(x)$ 所需要的信息编码长度（单位：nats）。当使用另一个编码分布函数 $q(x)$ 去编码 $p(x)$ 分布函数负责编码的信息时，由于$q(x)$和$p(x)$之间可能存在差距，导致编码效率不是最高的，因此会付出额外的一些冗余编码作为代价。对应的总编码长度(交叉熵)的计算公式：H(p,q)=-\int p(x)ln^{q(x)}dx$H(p.q)$称为交叉熵(cross entropy)，前后两种分布函数进行编码导致的编码长度差就是本文需要强调的KL散度。KL散度KL散度(相对熵)：量化两种概率分布P和Q之间差异的指标。KL(p||q)=H(p,q)-H(p)=-\int p(x)ln\frac{q(x)}{p(x)}=\int p(x)ln\frac{p(x)}{q(x)}KL散度的性质：KL散度大于等于零；KL散度不满足对称性，即$KL(p||q) \neq KL(q||p)$，因此其不是两种分布函数之间的距离度量；KL散度在机器学习中的目标是使其最小，也就是令一个参数化的分布q区接近真实的分布p；Reference信息熵和KL散度如何理解K-L散度（相对熵）Some say the world will end in fire,Some say in ice.From what I’ve tasted of desireI hold with those who favor fire.But if it had to perish twice,I think I know enough of hateTo say that for destruction iceIs also greatAnd would suffice.]]></content>
      <categories>
        <category>信息论</category>
      </categories>
      <tags>
        <tag>熵</tag>
        <tag>KL散度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PCA的理解]]></title>
    <url>%2F2019%2F07%2F06%2FPCA%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[有一点很值得强调，PCA算法是一种线性变换，灵活性和表示能力不如自动编码器等采用网络表征形式（既能表征线性变换，也能表征非线性变换）的算法。PCA对数据进行预处理的原因在机器学习算法和深度学习任务中，经常需要对原始输入数据进行中心化处理和标准化处理。数据中心化：减去均值等同于坐标移动，这样就能把原始数据点的中心移到与原点重合，此举有利于很多表达，比如数据的协方差矩阵可以直接写成$XX^T$，若没有减去均值，则每两个特征之间都要进行$(x-\bar{x})(y-\bar{y})$运算，再组合成协方差矩阵。数据标准化：除以标准差是为了统一并消除量纲。一个样本中有多个特征，有些可能表示长度，有些可能表示重量。如果各个特征之间的数值或数量级存在较大差异，就会使得较小的数被淹没，导致主成分偏差较大。所以要将每个特征对应的样本除以标准差，这样才能让他们仅以数的概念一起比较运算。注意：标准化与归一化 标准化指对数据既进行中心化也进行标准化，也就是既减去均值，也除以标准差；而归一化只将原始数据除以标准差，不减去均值；对图像进行PCA前数据预处理时，不需要除以标准差，即无需统一量纲。理由：图像的每个pixel的取值范围为[0, 255]，量纲已统一；PCA进行降维的心得在对文本数据(如短信)进行PCA降维时，一般将每条文本数据看作一个样本，首先将每条文本数据转化为${k}\times {1} $的词向量($k$为特征数)，则$N$条文本数据对应的数据矩阵$X$的尺寸为$k\times N$。文本数据矩阵的元素$X_{ij}$进行标准化：u_i=\frac{1}{N}\sum_{j=0}^{N-1}{X_{ij}}\sigma_{i}=\frac{1}{N-1}\sum_{j=0}^{N}(X_{ij}-u_i)Y_{ij}=(X_{ij}-u_{i})/\sigma_{i}对图像数据进行PCA降维时，实际上是在对每个图像样本(即每张图片)进行降维。自然图像的$pixel_value~\epsilon [0, 255]$，属于同一量纲，因此不需要除以标准差；对每张图片进行pixel_wise中心化时，减去的均值是整张图片的平均值，也就是图片的平均亮度，这一点和文本数据的预处理有很大不同；预处理完成后，便是对预处理后整张图的数据矩阵$W\times D$进行PCA降维，等同于将行数或列数视作样本数，而列数或行数视作特征数；深度学习中数据归一化的原因首先如果输入层 $ x $ 很大，在back propagation时传递到输入层的梯度就会很大，如下式：\frac{\partial{E}}{\partial{w_{11}^{2}}}=x_1\delta_1^{(2)}如果梯度非常大，学习率就必须非常小（否则会跳过local minimum），因此，学习率（学习率初始值）的选择需要参考输入层的数值，不如直接将数据归一化，这样学习率就不必再根据数据范围作调整。ReferencePCA要对数据进行预处理的原因PCA在图像降维的应用数据归一化Some say the world will end in fire,Some say in ice.From what I’ve tasted of desireI hold with those who favor fire.But if it had to perish twice,I think I know enough of hateTo say that for destruction iceIs also greatAnd would suffice.]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自编码器(AE)和变分编码器(VAE)]]></title>
    <url>%2F2019%2F07%2F06%2F%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8-AE-%E5%92%8C%E5%8F%98%E5%88%86%E7%BC%96%E7%A0%81%E5%99%A8-VAE%2F</url>
    <content type="text"><![CDATA[近期在看胶囊网络（Capsule Networks）相关的Survey，发现里面涉及的自编码器相关的内容有点遗忘，本文应运而生…无监督预训练网络无监督，顾名思义，不需要任何标注信息。无监督预训练网络可以进一步细分成自动编码器深度信念网络生成对抗网络本文主要就自动编码器及其相关进行展开。自编码器（AE）如今，数据可视化的数据降噪和降维被认为是自编码器的两个主要的实际应用。使用适当的维度和稀疏性约束，自编码器可以得到比PCA或其他类似技术更好的数据投影。自编码器通过数据示例自动学习。这意味着很容易训练在特定类型的输入中表现良好的算法的特定实例，并且不需要任何新的结构，只需适当的训练数据即可。但是，自编码器在图像压缩方面做得并不好。由于自编码器是在给定的一组数据上进行训练的，因此它将得到与所用训练集数据相似的压缩结果，但对通用的图像压缩器来说效果并不好。至少不如像JPEG这样的压缩技术。自编码器被训练成，可以在输入通过编码器和解码器后保留尽可能多的信息，但也会被训练成，使新的表示具有各种不错的属性。不同类型的自编码器旨在实现不同类型的属性。原理自动编码器是一种只有三层的神经网络：输入层、隐藏层(编码层)和解码层。该网络的目的是重构其输入，使其隐藏层学习到输入的良好特征表示。自动编码器神经网络是一种无监督机器学习算法，其应用了反向传播，可将目标值设置成与输入值相等。自动编码器的训练目标是将输入复制到输出。在内部，它有一个描述用于表征其输入的代码的隐藏层。自编码器的目标：学习函数 $h(x)\approx x$，其中x是输入，h(x)是自编码器经过编码和解码后的输出。也就是说，自编码器需要学习一个近似恒等函数，使得输出近似等于输入。因为中间隐藏层的维度比输入输出层的维度小很多，在神经网络推断过程中如果把隐藏层的参数拿出来，通过神经网络前向传播就产生输出值x,相当于从低维到高维的解压缩过程，而输入层到隐藏层的高维到低维的过程可看作压缩过程。当然我们讨论的是理想情况，神经网络基本不可能实现x=f(x)，在压缩后再解压的过程会产生损失，可类比于有损压缩。自编码器的特点：一种类PCA的无监督算法最小化目标函数和PCA的一致一种简单神经网络训练目标，网络输入近似等于网络输出注意：自编码器从某种程度上和PCA很相似，但自编码器比PCA灵活很多。由于自编码器是一种简单神经网络，决定了它既能表征线性变换也能表征非线性变换；而PCA只能通过线性变换实现降维。自编码器可将其作为层构建深度学习网络。类型自编码器主要有以下四类：去噪自编码器 最基本的一种自编码器，通过随机地部分采用受损的输入来解决恒等函数风险，使得自动编码器必须进行恢复或去噪，该技术可用于得到输入的良好表征。良好的表征是指可以从受损的输入稳健地获得的表征，该表征可被用于恢复其对应的无噪声输入。去噪自动编码器背后的思想很简单，为了迫使隐藏层发现更加稳健的特征并且为了防止其只是学习其中的恒等关系，我们在训练自动编码器时会让其从受损的版本中重建输入。应用在输入上的噪声量以百分比的形式呈现。一般来说，30% 就很好，但如果你的数据非常少，可能就需要考虑增加更多噪声。稀疏自编码器 通过在训练期间对隐藏单元施加稀疏性（同时保持隐藏单元的数量比输入更多），自动编码器可以在输入数据中学习有用的结构。 这种对输入的稀疏表示在分类任务的预训练中很有用。一般可以通过训练期间在损失函数中添加附加项来实现稀疏性或通过手动将除了几个最重要的隐藏单元全部调零（k稀疏自动编码器，k-sparse autoencoder）。变分自编码器 变分自编码器模型继承了自编码器体系结构，但对潜变量的分布做出了强有力的假设。他们使用变分方法进行潜在表示学习，但这会导致额外的损失和并需要特定的训练算法——称为随机梯度变分贝叶斯（SGVB）。收缩/压缩自编码器 收缩自动编码器在它们的目标函数中增加了一个正则项，迫使模型学习一个对输入值的细微变化具有鲁棒性的函数。信息熵和KL散度这部分内容见本人的博文 理解KL散度（相对熵）变分自编码器（VAE）变分自编码器由Diederik P Kingma和Danilo Jimenez Rezende在2013年提出，因为其坚实的理论基础、应用的多样性和比MCMC更优异的性能让它生成模型中得到广泛的研究和改进，现在已经成为生成模型算法中的一大主力。如下图的MNIST的手写体数据库图片的生成和名人图片就是使用VAE生成的。变分自编码器理论涉及不少统计学习的内容而目前的实现方法大多是基于深度神经网络。本文以图像识别为例讲解VAE，实际上VAE在文本、语音、视频等领域都可以应用，具体实现采用人工神经网络，实际上VAE也可以用其它的优化技术实现，它是一种很普适的生成模型算法。从神经网络角度看vae从神经网络角度看，变分自编码器由编码器、解码器和损失函数三部分组成。编码器是一个神经网络，它的输入是一个数据点 $x$ ，输出是变分自编码器的隐藏表示 $z$ ，同时它有权重和偏置参数 $\theta$ 。举个例子，假设 $x$ 是一张大小为$28\times 28$的手写数字图片，那么编码器的作用就是负责将上述$784$维的输入数据点编码为隐藏表示空间的 $z$（隐藏层维数是$h$，$h\ll784$）。隐藏层的维数远小于输入层数据点的维数归因于编码器必须学习一种将高维输入数据有效压缩到低维空间的表示。编码器用来拟合 $z$ 的条件分布 $q_\theta(z|x)$ 满足相互独立的高斯分布，实际上编码器就是用于生成这些高斯分布的参数 $(u_1,\sigma_1^{2}),(u_2,\sigma_2^{2}),…,(u_h,\sigma_h^{2})$ 。解码器是变分自编码器的另一部分神经网络，用条件概率 $p_\phi(x|z)$ 表示，它的输入是 $z$ 的表示，输出是数据概率分布所需要的参数 $\phi$ (包括权重和偏置)。同样以 $28\times 28$ 手写数字为例，令输入手写数字图片为黑白图片，每个pixel的值是 0 或 1 。那么，单个pixel的概率分布能表示为伯努利分布。解码器以 $z$ 作为输入并输出784个伯努利分布的参数 ，每个参数表示784个像素点的其中一个。解码器对数字向量 $z$ 进行解码，输出784个取值为 0或1 的数字，不可避免的解码结果和输入的784维存在差异，这个差异用损失函数进行度量。从神经网络的角度看，变分自编码器的损失函数由一个负的似然函数加上一个正则项组成。由于没有一个全局的表示能够一次计算所有数据点的损失，这里将总的损失分解为每个数据点对应的损失$li$的求和 $\sum{i=1}^{N}l_i$ 。下面是单个数据点的损失函数表达式：l_i(\theta,\phi)=-\mathbb{E}_{z\backsim q_\theta(z|x_i)}[logp_\phi(x_i|z)]+\mathbb{KL}(q_\theta(z|x_i)||p(z))从神经网络角度，第一个部分表示重建损失（第$i$个数据点的对数似然的负期望）这部分的理解我还有点迷。第一部分表达式鼓励解码器更好的重建原始数据，当重建效果不佳时，这部分损失会很大。第二部分是正则项，计算的是编码器的分布 $q_\theta (z|x)$ 和 $z$ 的先验概率分布 $p(z)$ 之间的KL散度。当使用q的条件概率分布去表示原始p的先验分布时，$z$ 的信息损失，也就是q分布与p分布的接近程度。在变分自编码器中，$p(z)=N(0,1)$ 。如果编码器输出的 $z$ 的表示不满足标准状态分布，将受到来自损失函数正则项的惩罚。正则项存在的作用就是确保两种分布尽可能的一致。训练过程使用梯度下降算法优化损失来完成，这里的损失与编码器和解码器的参数 $\theta$ 和 $\phi$ 有关。使用步长为 $\rho$ 随机梯度下降算法时，编码器参数更新表达式：$\theta\gets \theta-\rho\frac{\partial l}{\partial \theta}$ ,解码器参数更新表达式：$\phi\gets \phi-\rho\frac{\partial l}{\partial \phi}$ 。从概率模型角度看vae说完从神经网络角度看待vae，接下来就是从概率推导角度对vae进行分析，这个角度也有助于更好地理解vae，它是可解释的，现在，你需要做的就是先把前面神经网络有关的一切都忘掉和无忌小哥学太极拳太极剑法一样，是不是很奈斯。从概率模型角度，变分自编码器由输入变量 $x$ 和潜在变量 $z$ 的特定概率模型组成，且满足联合概率密度公式 :p(x,z)=p(x|z)p(z)对每个输入数据点 $i$ :潜在变量 $z_i \sim p(z)$输入数据点 $x_i\sim p(x|z)$相应图模型表示上图是从概率模型角度解释变分自编码器的核心目标，潜在变量由先验概率 $p(z)$ 表示，输入数据的似然 $p(x|z)$ 以潜在变量 $z$ 为条件。概率模型定义了基于输入数据和潜在变量的联合概率分布： $p(x,z)$ ，其和似然（条件概率）和 $z$ 的先验的关系： $p(x,z)=p(x|z)p(z)$ 。对于二值图像，似然满足伯努利分布。概率模型的目标式在给定输入数据的情况下推断出潜在变量好的表示，也就是推断出好的后验概率 $p(z|x)$。用贝叶斯公式表示，就是p(z|x)=\frac{p(x|z)p(z)}{p(x)}这里需要通过对 $x,z$ 联合概率密度求边缘积分计算贝叶斯公式的分母 $p(x)$ ：p(x)=\int p(x|z)p(z)dz不幸地，当潜在变量 $z$ 的维数 $h$ 很大时， 在高维空间进行积分没有操作性。因此需要使用 $q_\lambda(z|x)$ 来近似后验分布函数 $p(z|x)$ ，这也是变分拟合操作存在的原因。顺便提一下，拟合后验分布函数也可以使用马尔科夫链蒙特卡罗方法(MCMC),不过一般MCMC算法对于图像数据，语音数据，视频数据这类高维数据计算量非常巨大，基本在算力上不可行。近似表示的分布和标准后验分布函数 $p(z|x)$ 为KL(q_\lambda(z\ |\ x)\ ||\ p(z\ |\ x))=E_{q_\lambda}[ln^{q_\lambda(z|x)}]-E_{q_\lambda}[ln^{p_(x,z)}]+ln^{p(x)}其中， $p(x)$ 是数据的分布，与参数无关，因此我们最小化KL散度时与其无关，定义：ELBO_\lambda=E_{q_\lambda}[ln^{p_(x,z)}]-E_{q_\lambda}[ln^{q_\lambda(z|x)}]那么KL(q_\lambda(z\ |\ x)\ ||\ p(z\ |\ x))+ELBO_\lambda=ln^{p(x)}因为KL散度不为负，因此 $ln^{p(x)}\geq ELBO\lambda$ ，$ELBO\lambda$ 就是 $ln^{p(x)}$ 的下界(evidence lower bound)，最小化变分后验概率分布与理论后验概率分布的KL散度相当于最大化 $ELBO_\lambda$ ,对于每一个数据输入 $x_i$ ，有ELBO_\lambda=E_{q_{\lambda_{x_i}}}[ln^{p_(x_i,z)}]-E_{q_{\lambda_{x_i}}}[ln^{q_{\lambda_{x_i}}(z|x)}]\\=E_{q_{\lambda_{x_i}}}[ln^{p_(x_i|z)}+ln^{p(z)}]-E_{q_{\lambda_{x_i}}}[ln^{q_{\lambda_{x_i}}(z|x)}]\\=E_{q_{\lambda_{x_i}}}[ln^{p_(x_i|z)}]-KL(q_{\lambda_{x_i}}(z|x_i)\,||\,p(z))令:l_i=KL(q_{\lambda_{x_i}}(z|x_i)\,||\,p(z))-E_{q_{\lambda_{x_i}}}[ln^{p(x_i|z)}]此为单个输入值时神经网络的损失函数，这里面没有不可计算的变量，可以使用随机梯度下降(SGD)之类的训练算法训练神经网络，也可以配合批正则化(batch normalization)去降低神经网络训练过程中的梯度弥散问题，让训练结果更加稳定可靠。再重新考虑一下 $l_i$ 的意义，第一项相当于给定数据后的条件后验概率与先验概率的距离，最小化此项可以让z最终的分布接近我们设定的先验分布，可以认为这是一个正则修正项，否则最终z的分布如果不符合我们设定的先验分布，我们从先验分布中随机取的点就不能被解码器网络正确解码，第二项是给定数据下对z条件分布下的对数似然函数，当最小化 $l_i$ 时就相当于最大化这个对数似然函数，相当于我们要让训练数据中编码器编码过的 $z$ ，再经过解码器后要与原始数据差距比较小，减少在压缩编码和解码过程中产生的噪声。Reference自动编码器深度学习：自动编码器基础和类型Building Autoencoders in Keras【AI数学】变分自编码器(VAE)CMU lec12.vae.pdf理解变分自编码器(VAE)如何理解K-L散度Some say the world will end in fire,Some say in ice.From what I’ve tasted of desireI hold with those who favor fire.But if it had to perish twice,I think I know enough of hateTo say that for destruction iceIs also greatAnd would suffice.]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch常用函数]]></title>
    <url>%2F2019%2F07%2F02%2Fpytorch%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[squeeze和unsqueezesqueeze()主要用于删除tensor张量中维数为1的指定维度，而unsqueeze用于在指定维度上插入一个新的维数为1的维度。Example:123456789101112&gt;&gt;&gt; x = torch.zeros(2, 1, 2, 1, 2)&gt;&gt;&gt; x.size()torch.Size([2, 1, 2, 1, 2])&gt;&gt;&gt; y1 = torch.squeeze(x)&gt;&gt;&gt; y1.size()torch.Size([2, 2, 2])&gt;&gt;&gt; y1 = torch.squeeze(x, 0)&gt;&gt;&gt; y1.size()torch.Size([2, 1, 2, 1, 2])&gt;&gt;&gt; y1 = torch.squeeze(x, 1)&gt;&gt;&gt; y1.size()torch.Size([2, 2, 1, 2])Example:12345678&gt;&gt;&gt; x = torch.tensor([1, 2, 3, 4])&gt;&gt;&gt; torch.unsqueeze(x, 0)tensor([[ 1, 2, 3, 4]])&gt;&gt;&gt; torch.unsqueeze(x, 1)tensor([[ 1], [ 2], [ 3], [ 4]])MaxPool的ceil_mode参数在介绍MaxPool的ceil_mode参数前，首先介绍下MaxPool2d的相关配置：MaxPool2dExample:123456&gt;&gt;&gt; # pool of square window of size=3, stride=2&gt;&gt;&gt; m = nn.MaxPool2d(3, stride=2)&gt;&gt;&gt; # pool of non-square window&gt;&gt;&gt; m = nn.MaxPool2d((3, 2), stride=(2, 1))&gt;&gt;&gt; input = torch.randn(20, 16, 50, 32)&gt;&gt;&gt; output = m(input)ceil_mode上面官网给出ceil_mode相关介绍：ceil_mode – when True, will use ceil instead of floor to compute the output shape将其置为True，则对输出进行向上取整；默认False情况下，对输出进行向下取整。Example:1234567891011121314151617181920212223242526# coding:utf-8import torchimport torch.nn as nnfrom torch.autograd import Variable class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.maxp = nn.MaxPool2d(kernel_size=2, ceil_mode=False) def forward(self, x): x = self.maxp(x) return x square_size = 6inputs = torch.randn(1, 1, square_size, square_size)for i in range(square_size): inputs[0][0][i] = i * torch.ones(square_size)inputs = Variable(inputs)print(inputs) net = Net()outputs = net(inputs)print(outputs.size())print(outputs)12345678910111213141516171819202122232425262728293031Variable containing: (0 ,0 ,.,.) = 0 0 0 0 0 01 1 1 1 1 12 2 2 2 2 23 3 3 3 3 34 4 4 4 4 45 5 5 5 5 5[torch.FloatTensor of size 1x1x6x6] torch.Size([1, 1, 3, 3])Variable containing: (0 ,0 ,.,.) = 1 1 1 3 3 3 5 5 5 [torch.FloatTensor of size 1x1x3x3]在上面的代码中，无论ceil_mode是True or False，结果都是一样但是如果设置square_size=5，那么当ceil_mode=True123456789101112131415161718192021222324252627Variable containing: (0 ,0 ,.,.) = 0 0 0 0 0 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4 [torch.FloatTensor of size 1x1x5x5] torch.Size([1, 1, 3, 3]) Variable containing: (0 ,0 ,.,.) = 1 1 1 3 3 3 4 4 4 [torch.FloatTensor of size 1x1x3x3]当ceil_mode=False123456789101112131415161718192021222324252627Variable containing: (0 ,0 ,.,.) = 0 0 0 0 0 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4 [torch.FloatTensor of size 1x1x5x5] torch.Size([1, 1, 2, 2]) Variable containing: (0 ,0 ,.,.) = 1 1 3 3 [torch.FloatTensor of size 1x1x2x2]ceil模式会把不足square_size的边给保留下来，单独另算。而floor模式则是直接把不足square_size的边给舍弃。Conv2d的dilation参数首先对Conv2d的各项配置参数进行介绍，然后再详细解释dilation参数Conv2d1CLASS torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode='zeros')Example:12345678&gt;&gt;&gt; # With square kernels and equal stride&gt;&gt;&gt; m = nn.Conv2d(16, 33, 3, stride=2)&gt;&gt;&gt; # non-square kernels and unequal stride and with padding&gt;&gt;&gt; m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2))&gt;&gt;&gt; # non-square kernels and unequal stride and with padding and dilation&gt;&gt;&gt; m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2), dilation=(3, 1))&gt;&gt;&gt; input = torch.randn(20, 16, 50, 100)&gt;&gt;&gt; output = m(input)dilationdilation参数意味着对卷积核进行膨胀，膨胀的部分用0进行填充，用术语讲称之为空洞卷积。空洞卷积在增加卷积核感受野的同时，参数并未增加，有效减少计算量。计算公式：kernel{\_}dilation = dilation\times(kernel-1)+1在 $kernel=3,dilation=2$ 情况下，卷积核膨胀的效果图如下：ReferencePyTorchPytorch中 maxpool的ceil_modecaffe卷积层延伸：卷积核膨胀详细解析Some say the world will end in fire,Some say in ice.From what I’ve tasted of desireI hold with those who favor fire.But if it had to perish twice,I think I know enough of hateTo say that for destruction iceIs also greatAnd would suffice.]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>torch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2019%2F06%2F27%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[查询相关find按规则查找某个文件或文件夹，包括子目录find . -name &#39;*.sh&#39; — 以.sh结尾的文件find . -name &#39;*channel*&#39; — 包含channel字符的文件find . -name &#39;build*&#39; — 以build开头的文件find . -name &#39;abc??&#39; — abc后面有两个字符的文件grep查找内容包含指定的范本样式的文件，Global Regular Expression Printgrep -n pattern files — 规则 -n表示显示行号grep -n &#39;PostsActivity&#39; AndroidManifest.xmlgrep -n &#39;\d&#39; AndroidManifest.xmlgrep &#39;aapt&#39; build-channel.xml — 文件中包含字符串的所有地方grep -n &#39;aapt&#39; build-channel.xml — 文件中包含字符串的所有地方，并显示行号ps -e | grep java — 所有java进程ps -e | grep -i qq —所有qq进程，不区分大小写find . -name &#39;*channel.xml&#39; | xargs grep -n &#39;aapt&#39; — 在以channel.xml结尾的文件中查找包含‘aapt’关键字的地方ls | grep &#39;channel&#39; — 包含channel关键字的文件which在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果which zipwhich grep查看命令tailtail [-f] [-c Number | -n Number | -m Number | -b Number | -k Number] [File]从指定点开始将文件写到标准输出。使用tail命令的-f选项可以方便的查阅正在改变的日志文件，tail -f filename会把filename里最尾部的内容显示在屏幕上，并且不断刷新，使你看到最新的文件内容。tail -f test.log，循环查看文件内容，Ctrl＋c来终止tail -n 5 test.log，显示文件最后5行内容tail -n +5 test.log，从第5行开始显示文件moremore [-dlfpcsu] [-num] [+/ pattern] [+linenum] [file…]more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。more +3 test.log，显示文件中从第3行起的内容more -5 test.log，设定每屏显示行数ls -l | more -5，每页显示5个文件信息more +/day3 test.log，查找第一个出现”day3”字符串的行，并从该处前两行开始显示输出lessless [options] [file…]与more命令一样，less命令也用来分屏显示文件的内容。但是二者存在差别：less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。用less命令显示文件时，用PageUp键向上翻页，用PageDown键向下翻页。要退出less程序，应按Q键。less test.log，查看文件ps -ef | less，查看进程信息并通过less分页显示history | less，查看命令历史使用记录并通过less分页显示less test1.log test2.log，浏览多个文件，n和p切换文件watchwatch [options] command每隔一段时间重复运行一个命令，默认间隔时间是2秒。要运行的命令直接传给shell（注意引用和转义特殊字符）。结果会展示为全屏模式，这样你可以很方便的观察改变watch -n 60 date，执行date命令每分钟一次，输入^C 退出watch -d ls -l，查看目录变化watch -d ’ls -l | fgrep joe’，想找joe用户的文件watch -d &#39;ls -l|grep scf&#39;，监测当前目录中 scf’ 的文件的变化watch -n 10 &#39;cat /proc/loadavg&#39;，10秒一次输出系统的平均负载watch -n 1 -d netstat -ant，每隔一秒高亮显示网络链接数的变化watch -n 1 -d &#39;pstree | grep http&#39;，每隔一秒高亮显示http链接数的变化文件相关vivi file按i键，进入编辑模式按esc键，进入命令模式12345678:w 保存文件但不退出vi :w file 将修改另外保存到file中，不退出vi:w! 强制保存，不推出vi:wq 保存文件并退出vi:wq! 强制保存文件，并退出viq: 不保存文件，退出vi:q! 不保存文件，强制退出vi:e! 放弃所有修改，从上次保存文件开始再编辑chmodchange mode，变更文件或目录的读、写、运行权限chmod [-cfvR] [—help] [—version] mode file…mode:权限设定字串，格式如下 : [ugoa…][[+-=][rwxX]…][,…]u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。chmod也可以用数字来表示权限，语法为：chmod abc file，如chmod 777 file其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。 r=4，w=2，x=1chmod 777 file，等同于 chmod a=rwx filechmod ug=rwx,o=x file，等同于 chmod 771 filechmod 4755 filename，可使此程序具有root的权限ls -l 可以查看列出当前用户的文件权限zipzip -r filename.zip filesdirzip -r test.zip ./*，把当前所有文件压缩到test.zipzip -r test.zip test，把test文件所有文件及目录，要是到test.zipzip -d test.zip test.txt，删除压缩文件中test.txt文件zip -m test.zip ./test.txt，向压缩文件中test.zip中添加test.txt文件zip -r test.zip file1 file2 file3 filesdir，处理多个文件和目录，空格隔开unzipunzip zip-file，解压到当前目录unzip -d dst-dir zip-file，解压到指定的目录，-d后为指定目录unzip -n zip-file，不覆盖已经存在的文件，-n为不要覆盖原有的文件unzip -n -d dst-dir zip-file，解压到指定的目录，不覆盖已经原有的文件unzip -o -d dst-dir zip-file，-o不必先询问用户覆盖原有文件unzip -l zip-file，仅查看压缩文件内所包含的文件tartar cvf test.tar test，把test下所有文件和目录做备份tar czvf test.tar.gz test，把test下所有文件和目录做备份并进行压缩tar xzvf test.tar.gz，把这个备份文件还原并解压缩tar tvf test.tar | more，查看备份文件的内容，并以分屏方式显示在显示器上tar czvf test.tar.gz test --exclude=test/svn，备份压缩并排除目录touch内存相关ps显示瞬间行程(process)的动态，ps [options] [—help]ps -A，列出所有的进程ps -w，显示加宽可以显示较多的资讯ps -au，显示较详细的资讯ps -aux，显示所有（包含其他用户）的进程ps命令详解ps命令介绍linux上进程有5种状态:运行(正在运行或在运行队列中等待)中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)top动态观察程序的变化，top [-d] | top [-bnp]top -d 2，每两秒钟更新一次top -b -n 2 &gt; /tmp/top.txt，将top的信息进行2次，然后将结果输出到/tmp/top.txttop -d 2 -pid 10604，仅观察PID＝10604的程序top命令介绍freefree [options]free命令可以显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer。在Linux系统监控的工具中，free命令是最经常使用的命令之一free -m，以MB为单位显示内存使用情况free -g，以GB为单位显示内存使用情况free -s 10，周期性的查询内存使用信息killkill [-s signal_name] pid…发送指定的信号到相应进程，The kill utility sends a signal to the processes specified by the pid operand(s)kill -l，列出所有信号名称kill -l SIGKILL，得到指定信号的数值，SIGKILL＝9kill -9 pid，强行中止进程，强大和危险的命令迫使进程在运行时突然终止，进程在结束后不能自我清理。危害是导致系统资源无法正常释放，一般不推荐使用，除非其他办法都无效。kill -HUP PID，停止和重启进程，该命令让Linux和缓的执行进程关闭，然后立即重启。在配置应用程序的时候，这个命令很方便，在对配置文件修改后需要重启进程时就可以执行此命令。kill -l PID，以优雅的方式结束进程，-l选项告诉kill命令用好像启动进程的用户已注销的方式结束进程。当使用该选项时，kill命令也试图杀死所留下的子进程。但这个命令也不是总能成功—或许仍然需要先手工杀死子进程，然后再杀死父进程。ps -ef | grep vim，查找进程网络相关pingping [参数] [主机名或IP地址]确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。ping -b 192.168.1.1，ping网关ping -c 10 192.168.1.2，ping指定次数ping -c 10 -i 0.5 192.168.1.2，时间间隔和次数限制的pingping -c 5 www.baidu.com，通过域名ping公网上的站点netstatnetstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][—ip]用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat -a，列出所有端口netstat -nu，显示当前UDP连接状况netstat -apu，显示UDP端口号的使用情况netstat -i，显示网卡列表netstat -g，显示组播组的关系netstat -s，显示网络统计信息netstat -l，显示监听的套接口netstat -n，显示所有已建立的有效连接netstat -e，显示关于以太网的统计数据netstat -r，显示关于路由表的信息netstat -at，列出所有 tcp 端口netstat -ap | grep ssh，找出程序运行的端口netstat -pt，在 netstat 输出中显示 PID 和进程名称netstat -anpt | grep &#39;:16064&#39;，找出运行在指定端口的进程telnettelnet[参数][主机]执行telnet指令开启终端机阶段作业，并登入远端主机。telnet 192.168.120.206service xinetd restart，启动telnet服务ifconfigifconfig [网络设备] [参数]ifconfig 命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。ifconfig -a 显示全部接口信息ifconfig -s 显示摘要信息（类似于 netstat -i）工具命令svnsvn co path --username name --password passwordsvn co -path -dirnamesvn add filesvn update -r m pathsvn update -r 200 test.php，更新到某个版本cvscvs history -ca | grep username | grep 01-01cvs history -ca | grep username | grep kp | grep 2012-10-&#39;[1 2][0-9]&#39;antAnt -arguments [target1,target2,target3,target4……]Ant构建文件能够将项目编译，打包，测试。若没有指定任何参数， Ant会在当前目录下检索build.xml文件，如果找到了就运行该文件，如果没有找到了会，会提示没有找到相关的build.xml文件。ant -h，表示提供ant命令参数任务ant -projecthelp | -p，显示当前build.xml的主要任务，例如显示clean、releaseant -version，显示当前ant版本ant -diagnostics，诊断当前ant的所有的配置ant -debug | -d，检索当前构建文件配置情况ant -quiet | -q，显示当前构建文件无依赖任务ant -emacs | -e，调用编辑当前构建文件编辑器ant -lib [path]，调用当前项目中jar，class文件ant -logfile |-l，调用运行当前项目中*.log文件ant -buildfile |- f | -file，调用运行类似build.xml的文件ant -propertyfile [name]，调用运行指定的属性文件ant -find | -s file，检索运行指定的构建文件ant -autoproxy，使用系统自动代理构建文件ant-main class，设置系统类库文件中主要类ant -nice number，设置主类线程允许的线程数mavenmvn archetype:create，创建 Maven 项目mvn compile，编译源代码mvn test-compile，编译测试代码mvn test，运行应用程序中的单元测试mvn site，生成项目相关信息的网站mvn clean，清除目标目录中的生成结果mvn package，依据项目生成 jar 文件mvn install，在本地 Repository 中安装 jarmvn eclipse:eclipse，生成 Eclipse 项目文件mvn -Dmaven.test.skip=true，忽略测试文档编译adbadb kill-serveradb start-serveradb devicesadb uninstall fileadb uninstall -k file，-k 参数,为卸载软件但是保留配置和缓存文件adb push &lt;本地路径&gt; &lt;远程路径&gt;，可以把本机电脑上的文件或者文件夹复制到设备(手机)adb pull &lt;远程路径&gt; &lt;本地路径&gt;，可以把设备(手机)上的文件或者文件夹复制到本机电脑adb reboot，重启adbReference那些年整理的Linux常用命令，简单明了Some say the world will end in fire,Some say in ice.From what I’ve tasted of desireI hold with those who favor fire.But if it had to perish twice,I think I know enough of hateTo say that for destruction iceIs also greatAnd would suffice.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim常用命令]]></title>
    <url>%2F2019%2F06%2F27%2Fvim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[使用前需要知道的vim 是对vi的扩展，文中的很多操作是vi通用的vi是区分大小写的命令的，也就是说 g与G 是不同的命令在不同模式下，快捷键是不一样的 模式分 一般模式 编辑模式 指令模式一般模式用于文件内部操作，编辑模式用于输入编写等，指令模式用于对文本文件进行操作常用操作进入一般模式为开始编辑，或者按esc后进入按键效果a,i,r,o,A,I,R,O进入编辑模式h,backspace左移动l,space右移动j下移动k上移动0,移动到行首$移动到行末，1$表示当前行的行尾，2$表示当前行的下一行的行尾b按照单词向前移动 字首e按照单词向后移动 字尾w按照单词向后移至次一个字首H移动到屏幕最上 非空白字M移动到屏幕中央 非空白字L移动到屏幕最下 非空白字G移动到文档最后一行gg移动到文档第一行v进入光标模式，配合移动键选中多行Ctrl+f向下翻页Ctrl+b向上翻页u撤销上一次操作``回到上次编辑的位置dw删除这个单词后面的内容dd删除光标当前行dG删除光标后的全部文字d$删除本行光标后面的内容d0删除本行光标前面的内容y复制当前行，会复制换行符yy复制当前行的内容yyp复制当前行到下一行，此复制不会放到剪切板中nyy复制当前开始的n行p,P,.粘贴ddp当前行和下一行互换位置J合并行Ctrl+r重复上一次动作Ctrl+z暂停并退出ZZ保存离开xp交换字符后面的交换到前面~更换当前光标位置的大小写，并光标移动到本行右一个位置，直到无法移动光标详细操作按键效果Ctrl+e向下滚动Ctrl+b向上翻页b按照单词向前移动 字首B按照单词向前移动 字首 忽略一些标点符号e按照单词向后移动 字尾E按照单词向后移动 忽略一些标点符号w按照单词向后移至次一个字首W按照单词向后移至次一个字首 忽略一些标点符号H移动到屏幕最上 非空白字M移动到屏幕中央 非空白字L移动到屏幕最下 非空白字G移动到文档最后一行gg移动到文档第一行(光标到句尾)光标到局首{光标到段落开头}光标到段落结尾nG光标下移动到n行的首位n$光标移动到n行尾部n+光标下移动n行n-光标上移动n行查找命令指令效果*向下查找同样光标的字符#向上查找同样光标的字符/code查找 code 一样的内容，向后?code查找 code 一样的内容，向前n查找下一处N查找上一处ma在光标处做一个名叫a的标记 可用26个标记 (a~z)`a移动到一个标记ad`a删除当前位置到标记a之间的内容:marks查看所有标记指令模式指令效果:q一般退出:q!退出不保存:wq保存退出:w filename另存为 filename:jumps历史编辑文档记录:set nu设置行号显示:set nonu取消行号显示:set显示设置参数:set autoindent自动缩排，回车与第一个非空格符对齐:syntax on/off根据程序语法高亮显示:set highlight高亮设置查看:set hlsearch查找代码高亮显示:nohlsearch暂时关闭高亮显示:set nohlsearch永久关闭高亮显示:set bg=dark设置暗色调:set bg=light设置亮色调屏幕翻滚按键效果Ctrl+f向文件尾翻一屏幕Ctrl+b向文件首翻一屏幕Ctrl+d向文件尾翻半屏幕Ctrl+u向文件首翻半屏幕插入命令按键效果i在光标前I在当前行首a在光标后A在当前行尾部o在当前行下新开一行O在当前行上新开一行r替换当前字符R替换当前行及后面的字符，直到按esc为止s从当前行开始，以输入的文本替代指定数目的字符S删除指定数目的行，并以输入的文本替代ncw,nCW修改指定数目n的字符nCC修改指定数目n的行删除命令按键效果ndw,nDW删除光标开始及其后 n-1 个字符dw删除这个单词后面的内容dd删除光标当前行dG删除光标后的全部文字d$删除本行光标后面的内容d0删除本行光标前面的内容ndd删除当前行，以及其后的n-1行x删除一个字符，光标后X删除一个字符，光标前Ctrl+u删除输入模式下的输入的文本多窗口模式指令效果:split创建新窗口Ctrl+w切换窗口Ctrl-w =所有窗口一样高Ctrl-w+方向键多窗口视图切换多文件编辑指令效果:args列出当前编辑的文件名:next打开多文件，使用 n(Next) p(revious)N(ext) 切换:file列出当前打开的所有文件vim 自定义技巧复制粘贴取消缩进1:set paste进入paste模式以后，可以在插入模式下粘贴内容，不会有任何变形这个参数做了这么多事：123456789textwidth设置为0wrapmargin设置为0set noaiset nosisofttabstop设置为0revins重置ruler重置showmatch重置formatoptions使用空值下面的选项值不变，但却被禁用123lispindentexprcindent绑定快捷键来激活/取消 paste模式1:set pastetoggle=&lt;F11&gt;出现粘贴换行符错位，设置一下 .vimrc123456" this can change way of paste words:set paste" default tabstop=8:set tabstop=4" use keyboard F11 to change paste mode:set pastetoggle=&lt;F11&gt;vim 缩进Normal Mode下，命令&gt;&gt;将对当前行增加缩进，而命令&lt;&lt;则将对当前行减少缩进在命令前使用数字，来指定命令作用的范围15&lt;&lt;在Insert/Replace Mode下Ctrl-Shift-t可以增加当前行的缩进Ctrl-Shift-d则可以减少当前行的缩进使用0-Ctrl-Shift-d命令，将移除所有缩进需要注意的是，当我们输入命令中的“0”时，Vim会认为我们要在文本中插入一个0，并在屏幕上显示输入的“0”；然后当我们执行命令0-Ctrl-Shift-d时，Vim就会意识到我们要做的是减少缩进，这时0会就会从屏幕上消失vim tab缩进tab缩进宽度默认为8个空格我们可以使用以下命令，来修改缩进宽度1234:set tabstop=4:set softtabstop=4:set shiftwidth=4:set expandtabtabstop:表示一个 tab 显示出来是多少个空格的长度默认 8softtabstop:表示在编辑模式的时候按退格键的时候退回缩进的长度当使用 expandtab 时特别有用。shiftwidth:表示每一级缩进的长度一般设置成跟 softtabstop 一样。 当设置成 expandtab 时缩进用空格来表示noexpandtab 则是用制表符表示一个缩进expandtab选项，用来控制是否将Tab转换为空格,但是这个选项并不会改变已经存在的文本，如果需要应用此设置将所有Tab转换为空格，需要执行1:retab!vim 自动缩进cindent1:set cindentvim可以很好的识别出C和Java等结构化程序设计语言，并且能用C语言的缩进格式来处理程序的缩进结构smartindent1:set smartindent在这种缩进模式中，每一行都和前一行有相同的缩进量，同时这种缩进形式能正确的识别出花括号，当遇到右花括号（}），则取消缩进形式。此外还增加了识别C语言关键字的功能。如果一行是以#开头的，那么这种格式将会被特殊对待而不采用缩进格式。autoindent1:set autoindent在这种缩进形式中，新增加的行和前一行使用相同的缩进形式显示隐藏符号默认不显示 :set nolist显示 :set invlist12" normal is :set nolist | show hide is :set invlist:set nolist使用vim寄存器使用vim寄存器 “+p 粘贴根本不用考虑是否自动缩进，是否paste模式，直接原文传递如果想保存原寄存器中内容而同时增加新的内容就要在yy前增加标签标签以双引号开始，跟着的是标签名称，可以是数字0-9，也可以是26个字母显示所有寄存器内容1:reg注意两个特殊的寄存器：* 和 +这两个寄存器是和系统相通的，前者关联系统选择缓冲区，后者关联系统剪切板通过它们可以和其他程序进行数据交换若寄存器列表里无 * 或 + 寄存器，则可能是由于没有安装vim的图形界面所致sudo apt-get install vim-gnome设置vim永远显示行号修改vim的配置文件加入 set nu1vi ~/.vimrc然后输入1set nu当然也可以输入其他配置类似12set nonusyntax onvimrc 常用配置123456789101112131415161718192021" open syntaxsyntax on" set not show line number can change by :set nu:set nonu" set show line number when in edit:set ruler" set tab button stop" default tabstop=8:set tabstop=4:set softtabstop=4:set shiftwidth=4:set expandtab" use keyboard F11 to change paste mode:set pastetoggle=&lt;F11&gt;" normal is :set nolist | show hide is :set invlist:set nolist" fix mac vim keyboard delete can not delete error, so as set backspace=indent,eol,startset backspace=2" ------------" install plug-in manager see https://github.com/VundleVim/Vundle.vim查看vim设置的样例文件linux 查看1find /usr/share/ -name "*example.vim"mac 查看方法1locate example.vim如果是第一次运行会报告错误，需要建立索引，根据提示操作即可，建议运行一次 updatedb找到标识为 example.vim 的文件就是样例Referencevim 常用快捷键及使用技巧Some say the world will end in fire,Some say in ice.From what I’ve tasted of desireI hold with those who favor fire.But if it had to perish twice,I think I know enough of hateTo say that for destruction iceIs also greatAnd would suffice.]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios端利用VPS搭建的shadowsocks自制vpn]]></title>
    <url>%2F2019%2F06%2F25%2Fios%E7%AB%AF%E5%88%A9%E7%94%A8VPS%E6%90%AD%E5%BB%BA%E7%9A%84shadowsocks%E8%87%AA%E5%88%B6vpn%2F</url>
    <content type="text"><![CDATA[依赖项Shadowsocks Serverios 手机安装有PP助手的Windows 操作系统PC操作步骤下载shadowrocket.ipa安装包到Windows电脑安装包百度云链接 密码:8aae将ios手机用数据线连接到Windows电脑 MAC OSX不可用；利用PP助手&gt;我的设备&gt;应用管理&gt;我的应用&gt;安装本地应用&gt;选择引用文件来选择已下载的shadowrocket.ipa文件在ios手机上进行安装；shadowrocket的配置在iOS 手机上安装成功shadowrocket安装成功，接下来便是要根据你在VPS上的Shadowsocks Server的配置(IP、端口号、密码、加密算法)来在手机上完成相应配置。下图是配置完以后，打开vpn进行使用的效果图👇那么具体该怎么配置呢，首先点击上图右上角的➕按钮，就能进入下图所示页面，然后在该页面中填好你的服务器上相应的配置信息，最后点击右上角的完成按钮，就大功告成啦！！！预知详细配置流程的朋友，请移步👉：iOS利器“小火箭”（Shadowrocket）最全使用教程ReferenceiOS利器“小火箭”（Shadowrocket）最全使用教程教你如何安装免费应用或者本地应用Some say the world will end in fire,Some say in ice.From what I’ve tasted of desireI hold with those who favor fire.But if it had to perish twice,I think I know enough of hateTo say that for destruction iceIs also greatAnd would suffice.]]></content>
      <categories>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>手机端</tag>
        <tag>shadowrocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 框架下404页面的设置]]></title>
    <url>%2F2019%2F06%2F25%2FHexo-%E6%A1%86%E6%9E%B6%E4%B8%8B404%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言​ 今天心情不错，Google Search Console 上一直报错通过不了的站点地图终于获取成功了…别问我为什么，它之前绝对是抽了，好好地把旧版更新到新版，结果各种问题。在sitemap这个问题上折腾了有四天多(上周四 — 本周二)，此处po图同庆下。​ 补充下站点地图的作用，搜索引擎的工作并非如常人所想，只要你发布相应的网页，内容就会被搜索引擎自动收录。而是需要网站向搜索引擎提交自身链接，然后相应的网页信息才会在搜索时按照rank机制进行显示。这里具体说明下Baidu常用的站点内容推送方式。多种推送站点内容的方案：主动推送：通过 API 接口推送站点内容，实时性较高自动推送：在网页内添加 JS 脚本，每当页面被访问的时候会将页面 url 推送给百度，比较被动sitemap：填写站点地图文件地址，百度会周期性的抓取其中的内容进行分析收录，收录效率比较低手动提交：手动填写链接地址进行收录本站在针对百度搜索引擎收录上使用三种推送方案：主动推送 该方式需要借助hexo-baidu-url-submit插件实现快捷推送，在根目录下安装相应依赖1npm install hexo-baidu-url-submit --save并在站点配置文件_confirg.yml上添加下列语句：123456# 百度主动推送baidu_url_submit: count: 100 # 提交最新的一个链接 host: yearito.cn # 在百度站长平台中注册的域名 token: xxxxx # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里然后在站点配置文件中修改部署策略123456789 # Deployment ## Docs: https://hexo.io/docs/deployment.html- deploy:- type: git- repo: git@yearito.cn:~/blog.yearito.git+ deploy:+ - type: git+ repo: git@yearito.cn:~/blog.yearito.git+ - type: baidu_url_submitter # 百度每次部署的时候将会自动推送网站内容到百度。自动推送 Next 主题配置文件中内置了一键开启百度自动推送的选项：12# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true每次访问站点页面都会通过以上脚本推送本页 url 到百度。sitemap 在站长页面提交属于自己网站的sitemap.xml文件，若判断提交成功，则搜索引擎的爬虫会间隔一段时间爬取sitemap中所收录网站页面的内容信息。​ 建议不采用主动推送方式进行内容推送，在你未将自己的GitHub pages仓库的属性设为private之前，这样做风险很大…​ 码到这感觉应该单独开个页面，系统讲述下以上内容，包括网站验证的几种方式、sitemap.xml的格式、robots.txt的具体配置等等，本站毕竟新开张，刚刚才被Google收录…陆陆续续我也会出相应的博文的，接下来回归正题。常规404页面常规404页面，便是你在主题配置_config.yml中把内置的menu下相应注释符号去掉，然后它会显示一个很难以描述的404页面，本质上和创建tags、categories等页面一样。还有一种常规方式就是创建腾讯公益的404页面，这也是hexo框架下很多用户会采取的404页面。既能有效提示页面不存在，还能做下公益，何乐而不为~言归正传，下面是该方式的具体操作步骤👇：进入本地hexo目录，输入以下命令1hexo new page "404"打开刚新建的页面文件，默认在 Hexo 文件夹根目录下 /source/404/index.md ，输入以下代码：12345678910111213141516---title: 404 Not Found：该页无法显示toc: falsecomments: falsepermalink: /404---&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;404&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" homePageName="返回首页" homePageUrl="https://www.nickyam.com"&gt;&lt;/script&gt;true&lt;/body&gt;&lt;/html&gt;然后部署上传1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d自定义404.html页面看到这里应该会有不少人会和我一样，想DIY属于自己的独特404页面，这个过程中本人也进行很多尝试，也总结出一些设置心得，首先推荐一个不错的HTML网站CodePen，上面有不少可以用来制作404页面的素材源码。制作自定义html页面，在hexo主题下会遇到各种bug:404页面只在一级域名下一级子路径下能正常跳转显示，在二级乃至三级···子路径下无法正常显示解决方法: 不要使用相对路径对依赖文件进行调用！！！使用链接形式对依赖文件进行调用12345//将 .html中下列语句&lt;script src="./rain_script.js"&gt;&lt;/script&gt;//修改为&lt;script src="https://zejinwang.com/rain_script.js"&gt;&lt;/script&gt;//注意:不要使用http为前缀的路径，Chrome不支持读取http外链按照很多博文描述的思路，将html依赖的css文件和js文件放在根目录下的source文件夹下或者source/你创建的page文件夹 下，在经过 hexo g 生成和 hexo d上传后，无法正常调用依赖的两个文件解决方法：将依赖的js和css依赖文件放到主题所在目录的source文件下，而不是hexo根目录下的source文件夹中创建步骤创建自定义page文件夹 1hexo new page "404 not found" 将‘’404 not found‘’文件夹下的index.md文件替换为你准备的index.html文件将index.html文件以来的css和js文件依赖放到主题目录下的source文件夹中修改theme目录下的主题配置文件中menu部分，添加上自定义page信息自定义页面效果展示见404特效和源码雨特效。ReferenceHexo博客添加腾讯404公益页面hexo创建404页面Hexo 搭建个人博客系列：部署上线篇Some say the world will end in fire,Some say in ice.From what I’ve tasted of desireI hold with those who favor fire.But if it had to perish twice,I think I know enough of hateTo say that for destruction iceIs also greatAnd would suffice.]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>404</tag>
        <tag>自定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个有关Wang's Blog诞生的故事]]></title>
    <url>%2F2019%2F06%2F22%2FHexo-%E6%90%AD%E7%AB%99%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[​ 谈到选择何种网站基础框架，自然少不了一番内心的天人交战：Wordpress？、Hexo?写到这里，其实是我词穷了，本来还想多列举一些可以用作网站搭建的框架，奈何只调研了这两个主要搭站框架此时此刻懒得去查。说到上面两个框架，不得不提本人搭站旅程中的艰辛坎坷：背景​ 在本站正式诞生之前，其实本人还搭过一个基于WordPress的网站，算算时间~~该故事不巧发生在北京时间2019年6月15日，传说中的上周…那时的我，还是折腾界的低级玩家 ：日常专注于踏踏实实的生活、看paper、上课、写作业，闲了敲敲专业相关的代码。在CSDN上分享paper reading后，发现其排版和网站界面做的真的是奇丑无比，难以忍受 (该观点仅代表 ZejinWang 的立场)。当时在考虑该入简书坑，还是掘金坑，这两家的风格个人还是比较喜欢的。那时的我还是个不懂如何使用VPS，如何创建VPN的萌新，对这一神秘领域又是向往又小心翼翼。​ 那么是什么促使我迈入高玩阵列？不是爱 2019年6月1日，在这全中国都洋溢着儿童节快乐气氛的日子里，翻墙界发生了一场波及全体成员的大地震，GFW出手了。此时此刻你还想重温翻车现场氛围的，请转往👉shadowsocks玩家的呐喊现场。嗯….很不幸的，室友的VPS被封了，共享给我的VPN不能用了，产生用户粘性的我，只能自力更生，丰衣足食…当时在Bandwagon和Vultr中犹豫许久，强迫症玩家总是任意抠细节，对比各种性能优势。有兴趣的朋友，见2019优质VPS服务商推荐。最后图稳定和性价比，选择了搬瓦工(学生党经济适用款)。​ 配置完shadowsocks server 和 client（加密方式建议 chacha20）就能继续愉快地科学上网了，说起来买的套餐一个月有1000G流量，完全用不完。有认识的朋友在浩如烟海的信息流中看到本帖，同时有翻墙需要，请毫不吝啬的call me！有机会我多出几个ssh相关的帖子（base linux or censos），共享给大家。WordPress初体验​ shadowsocks已经搭建完毕，巨额月流量也足够本人肆意挥霍，高枕无忧~~然而，故事到此才刚刚开始…看着VPS中1024MB RAM只使用了200MB而已，不足20%。这对经常把计算资源利用到极(崩)致(溃)的人，这怎么能忍。查了前人利用VPS常干的事，发现目前而言搭个人博客对我来说是最适合的。Hexo or Wordpress ? 本着操作尽量方便简单，同时保持网站加载速度的原则，当时的我天真的选择了后者。​ 折腾WordPress大概也有一周时间吧，没想到看着教程颇为简单的它，在自定义网站环节的操作难度会如此大。估计是我对直接操作UI这方面实在是没什么天赋，就和从小到大我那贫瘠的艺术细胞那样…就这样折腾完后，网站静态页面和博客主页成型了，然而我也决定放弃后续操作，太折腾，太难弄美观了，嗯，先罢工一段时间吧…Hexo的见猎心喜​ 实习的时候，看到工位边上的张同学在尝试用hexo作为框架搭建个人博客，瞄过几眼后，我心动了…决定再次开工，搭建基于Hexo + Github的个人博客。​ 确定搭建基于Hexo + Github框架的个人博客的方案后，接下来便是付诸实践的时候。当时首先考虑到的是该选择哪款主题作为基础，然后在上面进行个性化定制，此处附hexo官网两百多款主题的直达通道。每当做选择的时候，总是最为心力交瘁的时刻，会进行很细致的效果对比、可操作空间大小、主题是否在及时优化迭代等，各方面因素导致自己在这个阶段浪费了不少时间。本人先后尝试了pure和next，在折腾pure主题的时候，很明显的感觉到pure的作者身为前端开发者，在代码习惯上并不是很OK，主题框架写的有点乱偏私人化，导致修改配置的接口做的不是很好，个性化订制中很容易出各种bug，体验很不美丽。最终考虑到next的生态更为完善、可改动空间极大，定稿使用后者。踩坑心得确定好你青睐的配置环境，按序安装相应依赖(版本不兼容对新手很不友好)学会更好地搜集资料，选择适合你选择的hexo+next版本的资料好的引路人可以让你少走很多弯路，好的教程也一样(推一套无死角教程免费替作者打广告)Hexo 搭建个人博客系列：基础建站篇Hexo 搭建个人博客系列：部署上线篇Hexo 搭建个人博客系列：进阶设置篇Hexo 搭建个人博客系列：主题美化篇Hexo 搭建个人博客系列：写作技巧篇操作细节上注意备份！！！作为一名IT从业者，备份意识怎么能不扎根心里…Some say the world will end in fire,Some say in ice.From what I’ve tasted of desireI hold with those who favor fire.But if it had to perish twice,I think I know enough of hateTo say that for destruction iceIs also greatAnd would suffice.]]></content>
  </entry>
</search>
